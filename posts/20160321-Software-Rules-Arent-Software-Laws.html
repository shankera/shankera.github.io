---
layout: post
selected-160321: true
selected-blog: true
title: Software Rules Aren't Software Laws
comments: true
---
<div id="content">
  <p>Model-View-ViewModel and similar design patterns were all created with the same goals. Improve testability by separating business logic from the View, so the business logic can be unit tested thoroughly. There are a few basic agreed upon rules for MVVM:</p>
  <ul>
    <li>The View should not contain any business logic.</li>
    <li>The View should get its data from the ViewModel, generally by binding. </li>
    <li>The ViewModel should not have a reference to the View. Updates to the view should be triggered by bindings or by invoking a delegate.</li>
    <li>The ViewModel should get its data from the Model from method calls.</li>
  </ul>
  <p>These are very good guidelines that can greatly help in pulling unit-testable code out of views, and allowing the Model to be mocked. However, I do have some general issues with the use of this pattern. To start, MVVM was originally concieved of with the Windows Presentation Framework (WPF) which is developed in C#. This made use of the tight coupling of a <code>.xaml</code> file and a <code>.xaml.cs</code> file which are linked together. The <code>.xaml</code> has UI elements that can be bound to properties in the <code>.xaml.cs</code> file. The code in the <code>.xaml.cs</code> files are still part of the View, and are therefore very difficult to unit test, but they can programmatically interact with other classes that do business logic and provide data. This allows those external pieces to be unit tested in isolation of the View.</p>
  <p>For me, the problems start coming when these patterns start being applied to architectures like Android and iOS. There are some semantics of these systems that do not play nicely with the rules of MVVM. For example, in both Android and iOS, navigating between views requires the use of an object that belongs to the View. For Android, you must call <code>startActivity(Intent intent)</code>, or an overload of it, in order to start and display a new Activity. For iOS, you need a reference to <code>UINavigationController</code>, which is an object that belongs to UIViewController, in order to push a new UIViewController on top of the stack. In order to adhere to our aforementioned rules, we are not allowed to reference the View or things that directly belong to it that the ViewModel does not already have visibility of.</p>
  <p>The problems come when you now need to trigger Navigation on the result of some business logic. The common solution is to implement a singleton 'Navigator' class, where you pass it some innocuous variable like a <code>String</code> or <code>enum</code> and it uses its own reference to the View's navigation functions in order to instantiate the new View and execute the navigation. This also allows the Navigator to be mocked for the sake of unit testing, so it doesn't actually attempt to initialize Views. While this can work, it requires having internal logic which parses whatever parameters are provided and translates that into a usable View, which means that the more screens there are, the more the Navigator grows in logic. This problem all stems from that first rule. If the navigation is based on the resulf of a service request, for example, then it could be considered business logic - regardless of the fact that it is fundamentally rooted in the View. Therefore, it would violate that first rule, and should not be done in accordance with MVVM.</p>
  <p>However, if you acknowledge that there is the possibility that some work may need to happen in the View, you can still control and test the business logic in the ViewModel, without creating something like a Navigator in order to do work. Potentially, each ViewModel could contain and invoke a Delegate, or Observable that the View is observing. The View could navigate on the trigger of the Observable. If there were multiple potential places to navigate, the ViewModel could invoke that Observable with a parameter of an enum or data object, or both if need be. The View would still have to execute the switch:case statement and navigate accordingly, but that's not more information than the Navigator implementation had, and it's limited to only the options that the single View can navigate to, as opposed to a massive singleton.</p>
  <p>The idea of MVVM is to improve the quality of code by enhancing testability, and the rules are loose guidelines to assist this. If they are taken to literally, and enforced unnecessarily just because 'that breaks the rules', then worse patterns will be implemented under the guise of being better, because they adhere to these guidelines.</p>
</div>
